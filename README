    1. Compresia
citesc dimensiunea imaginii, aloc memorie pentru matricea de pixeli, pe care o citesc din fisierul binar
linie cu linie. Pentru calculul culorii medii si a scorurului de similaritate am definit o functie ce calculeaza
media in timp ce se calculeaza si suma, pastrand intregii din fractie si resturile, pentru a evita overflow-ul
prin acumularea unor valori mari in suma. Daca scorul de similaritate nu este suficient de bun, descompun 
nodul curent, deci apelez functia de creare a unui nod pentru fiecare din cei 4 fii, cu submatricea de pixeli
corespunzatoare (caracterizata de coltul din stanga-sus si dimensiune).In timp ce construiesc arborele 
numar si frunzele si nodurile, pentru a afla cata memorie trebuie alocata pentru vector.
Folosind o parcurgere in latime a arborelui il transpun in vector, pe care il scriu apoi in fisierul binar.

    2.Decompresia
citesc vectorul din fisierul binar. Pentru constructia arborelui din vector folosesc o functie recursiva,
care se apeleaza intial pentru nodul radacina, si apoi pentru fiecare descendent. Se folosesc indicii salvati in 
vector catre fii pentru a se construi legaturile dintre noduri. Parcurg arborele folosind parcurgerea in adancime,
cand gasesc un nod frunza ii scriu culoarea in matricea de pixeli, in zona si pe dimensiunea corespunzatoare.
Scriu dimensiunea imaginii (dimensiunea nodului radacina) in fisierul PPM, si apoi matricea linie cu linie

    3.Oglindirea
folosesc functiile de la compresie pentru citirea imaginii in matrice, creearea arborelui din aceasta. Apoi parcurg
arborele in adancime si pentru fiecare nod intern interschimb, dupa caz, fiii reprezentand submatricele de sus
cu cele de jos sau cele din stanga cu cele din dreapta. Apoi folosesc functiile de la decompresie pentru a trece
noul arbore inapoi in formatul matriceal si pentru a scrie matricea de pixeli in fisier.